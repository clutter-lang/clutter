;; Types

(def-op! declare! (&rest #ignore)
  #t)

(def-op! enum (&rest keywords)
  (list :enum keywords))

(def-op! enum-case env (var &rest forms)
  (if (eql? (eval var env) (eval (car (car forms)) env))
      (eval (list* do (cdr (car forms)))
            env)
      (eval (list* enum-case var (cdr forms)) env)))

(def! type :type)
(def! number :number)
(def! char :char)
(def! bool :bool)

(def-fun! type-combiner (type left right)
  (list type left right))

(def-fun! tc? (tc)
  (and? (sequence? tc)
        (any? (lambda (x) (eql? x (car tc)))
              (list :op :fun :prod))))

(def-fun! tc-constructor (tc)
  (first tc))

(def-fun! tc-constructor-fun (tc)
  (enum-case (tc-constructor tc)
    (:prod prod)
    (:op op)
    (:fun fun)))

(def-fun! tc-left (tc)
  (second tc))

(def-fun! tc-right (tc)
  (third tc))

(def-fun! op (from to)
  (type-combiner :op from to))

(def-fun! fun (from to)
  (type-combiner :fun from to))

(def-fun! prod (left right)
  (type-combiner :prod left right))

(def-fun! prod-list (&rest values)
  (if (empty? (car values))
      unit
      (if (empty? (cdr values))
          (car values)
          (prod (car values) (apply prod-list (cdr values))))))

(def-fun! tc-equal? (left right)
  (and?
   (eql? (tc-constructor left) (tc-constructor right))
   (type-equal? (tc-left left) (tc-left right))
   (type-equal? (tc-right left) (tc-right right))))

(def-fun! tc-equalable? (left right))

(def-fun! make-base-decl ()
  (let (decl (make-env))
    (def-in! decl declare! :declare-type)
    (def-in! decl lambda :lambda-type)
    (def-in! decl cons :cons-type)
    (def-in! decl prod :prod-type)
    (def-in! decl op :op-type)
    (def-in! decl fun :fun-type)
    (def-in! decl type :type)
    (def-in! decl number :type)
    (def-in! decl char :type)
    (def-in! decl bool :type)
    decl))

(def-op! normalize env (type #ignore) ;; TODO: decent normalization
   type)

(def-fun! type-equal? (left right)
  (if (and? (tc? left) (tc? right))
      (tc-equal? left right)
      (eql? left right)))

;; Inference

(def-op! infer-code env (code decl)
  (let (ast (mark-ast code))
    (substitute-vars ast (unify (make-constraints ast (eval decl env))))))

(def! type-var? symbol?)

(def-fun! mark-ast (ast)
  (let (counter 0)
    (letrec (mark-ast-helper
             (lambda (ast)
               (let (current counter)
                 (set! counter (+ counter 1))
                 (cons (if (cons? ast)
                           (map mark-ast-helper ast)
                           ast)
                       (intern current)))))
      (mark-ast-helper ast))))

(def-fun! substitute-vars (ast constraints)
  (let* (form (car ast)
         var (cdr ast))
    (cons (if (cons? form)
              (map (rcurry substitute-vars constraints) form)
              form)
          (do
           (let (subst (find-constraint var constraints))
             (if (false? subst)
                 :unknown
                 (constraint-right subst)))))))

;; Constraints

(def-fun! make-constraint (left right)
  (list :constraint left right))

(def-fun! constraint? (c)
  (and? (sequence? c)
        (eql? (car c) :constraint)))

(def-fun! constraint-left (c)
  (second c))

(def-fun! constraint-right (c)
  (third c))

(def-fun! find-constraint (key list)
  (if (empty? list)
      #f
      (if (eql? key (constraint-left (car list)))
          (car list)
          (find-constraint key (cdr list)))))

(def-fun! make-constraints (form decl)
  (let (actual-form (car form)
        tv (cdr form))
    (if (not (cons? actual-form))
        (make-atom-constraints actual-form decl tv)
        (if (not (cons? (car (car actual-form))))
            (let (comb (eval (car (car actual-form)) decl))
              (cond
                ((eql? comb :declare-type) (make-annotation-constraints actual-form decl tv))
                ((eql? comb :cons-type) (make-pair-constraints actual-form decl tv))
                ((eql? comb :lambda-type) (make-lambda-constraints actual-form decl tv))
                ((any? (curry eql? comb) (list :prod-type :op-type :fun-type)) (make-type-combiner-constraints actual-form decl tv))
                (#t (make-combiner-constraints actual-form decl tv))))
            (make-combiner-constraints actual-form decl tv)))))

(def-fun! make-atom-constraints (atom decl tv)
  (list
   (make-constraint tv
               (cond
                 ((number? atom) number)
                 ((boolean? atom) bool)
                 (#t (eval atom decl))))))

(def-fun! make-annotation-constraints (form decl tv)
  (destructuring-bind (_ name decl-type) form
    (dyn-def-in! decl (car name) (cdr decl-type))
    (append
     (list
      (make-constraint tv bool))
     (make-constraints decl-type decl))))

(def-fun! make-pair-constraints (form decl tv)
  (destructuring-bind (_ left right) form
    (append
     (list
      (make-constraint tv (prod (cdr left) (cdr right))))
     (make-constraints left decl)
     (make-constraints right decl))))

(def-fun! make-lambda-constraints (form decl tv)
  (destructuring-bind (_ lambda-list &rest body) form
    (let* (lambda-decl (make-env decl))
      (map (lambda (p) (dyn-def-in! lambda-decl (car p) (cdr p))) (car lambda-list))
      (append
       (list
        (make-constraint tv (fun (apply prod-list (map cdr (car lambda-list))) (cdr (last body)))))
       (reduce (lambda (prev next) (append (make-constraints next lambda-decl) prev)) (list) body)))))

(def-fun! make-type-combiner-constraints (form decl tv)
  (destructuring-bind (_ left right) form
    (append
     (list
      (make-constraint tv type)
      (make-constraint (cdr left) type)
      (make-constraint (cdr right) type))
     (make-constraints left decl)
     (make-constraints right decl))))

(def-fun! make-combiner-constraints (form decl tv)
  (destructuring-bind (comb &rest args) form
    (let* (comb-constraints (make-constraints comb decl)
           comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
      (append
       (list
        (make-constraint tv (tc-right comb-type))
        (make-constraint (cdr comb) comb-type)
        (make-constraint comb-type (fun (apply prod-list (map cdr args)) tv)))
       comb-constraints
       (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;; Unification

(def-fun! unify (constraints)
  (def-fun! unify-h (stack substs)
    (if (empty? stack)
        substs
        (let* (next (car stack)
               left (constraint-left next)
               right (constraint-right next))
          (cond
            ((type-equal? left right) (unify-h (cdr stack) substs))
            ((type-var? left) (unify-h
                               (substitute-constraints next (cdr stack))
                               (cons next (substitute-constraints next substs))))
            ((type-var? right) (unify-h
                                (cons (make-constraint right left) (cdr stack))
                                substs))
            ((and? (tc? left)
                   (tc? right))
             (unify-h
              (append (unify-tc left right) (cdr stack))
              substs))
            (#t (print "Can't unify!")
                (print left)
                (print right)
                (list))))))
  (unify-h constraints (list)))

(def-fun! unify-tc (left right)
  (list
   (make-constraint (tc-left left) (tc-left right))
   (make-constraint (tc-right left) (tc-right right))))

(def-fun! substitute-constraints (subst constraints)
  (map (lambda (constraint)
         (make-constraint
          (substitute-side subst (constraint-left constraint))
          (substitute-side subst (constraint-right constraint))))
       constraints))

(def-fun! substitute-side (subst side)
  (cond
    ((eql? side (constraint-left subst)) (constraint-right subst))
    ((tc? side) ((tc-constructor-fun side)
                 (substitute-side subst (tc-left side))
                 (substitute-side subst (tc-right side))))
    (#t side)))

;; (def-op! check-op env (form type decl)
;;   (check form type (eval decl env)))

;; (def-fun! check (form type decl)
;;   (let (type (infer type decl))
;;     (if (not? (cons? form))
;;         (type-equal? type (infer form decl))
;;         (let (comb (eval (car form) decl))
;;           (cond
;;             ((eql? comb :cons-type) (check-pair form type decl))
;;             ((eql? comb :lambda-type) (check-lambda form type decl)) ;; Should be vau
;;             (#t (type-equal? type (infer form decl))))))))

;; (def-fun! check-type-constructor (left right type decl)
;;   (let (left-value (normalize left decl))
;;     (and?
;;      (check left-value (tc-left type) decl)
;;      (check right-value ((tc-rigth type) left-value) decl))))

;; (def-fun! check-pair (form type decl)
;;   (destructuring-bind (_ left right) form
;;     (check-type-constructor left right type decl)))

;; (def-fun! check-lambda (form type decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - &rest handling
;;     (check-type-constructor (car lambda-list) body))) ;; TODO - should handle multi-argument lambda-lists

;; (def-op! infer-op env (form decl)
;;   (infer form (eval decl env)))

;; (def-fun! infer (form decl)
;;   (if (not? (cons? form))
;;       (infer-atom form decl)
;;       (let (comb (eval (car form) decl))
;;        (cond
;;          ((eql? comb :declare-type) (infer-annotation form decl))
;;          ((some? (curry eql? comb) (list :prod-type :op-type :fun-type)) (infer-type-combiner form decl))
;;          ((eql? comb :cons-type) (infer-pair form decl))
;;          ((eql? comb :lambda-type ) (infer-lambda form decl))
;;          (#t (infer-comb form decl))))))

;; (def-fun! infer-atom (atom decl)
;;   (cond
;;     ((number? atom) number)
;;     ((boolean? atom) bool)
;;     (#t (eval atom decl))))

;; (def-fun! infer-annotation (form decl)
;;   (destructuring-bind (_ symbol value) form
;;     (if (check value type decl)
;;         (do
;;          (dyn-def-in! decl symbol (infer value decl))
;;          bool)
;;         #f)))

;; (def-fun! infer-type-combiner (form decl)
;;   (destructuring-bind (_ left right) form
;;     (if (and?
;;          (check left type decl)
;;          (or?
;;           (check right type decl)
;;           (check right (fun left type) decl)))
;;         type
;;         #f)))

;; (def-fun! infer-pair (form decl)
;;   (destructuring-bind (_ left right) form
;;     (prod (infer left decl) (infer right decl))))

;; (def-fun! infer-lambda (form decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - should handle &rest for body
;;     (let (lambda-decl (make-env decl)
;;           type-variables (make-type-variable-list (length lambda-list)))
;;       (map (lambda (p) (extend lambda-decl (car p) (cdr p)))
;;            (zip (lambda-list) type-variables))
;;       (fun (apply prod-list type-combiner) (infer body lambda-decl)))))

;; (def-fun! infer-comb (form decl)
;;   (destructuring-bind (comb arg) form ;; TODO should handle multi-argument functions and should handle vau
;;     (let (comb-type (infer comb decl)
;;                     arg-type (infer arg decl))
;;       (if (check (tc-left comb-type) arg-type decl)
;;           (tc-right comb-type)
;;           #f))))