;;;; Inference

;;; Entry level

(def-op! infer-code env (code decl)
  (let (ast (mark-ast code))
    (substitute-vars ast (unify (make-constraints ast (eval decl env))))))

;;; AST marking

(def! type-var? symbol?)

(def-fun! mark-ast (ast)
  (let (counter 0)
    (letrec (mark-ast-helper
             (lambda (ast)
               (let (current counter)
                 (set! counter (+ counter 1))
                 (cons (if (cons? ast)
                           (map mark-ast-helper ast)
                           ast)
                       (make-variable current)))))
      (mark-ast-helper ast))))

(def-fun! substitute-vars (ast constraints)
  (let* (form (car ast)
         var (cdr ast)
         subed-form (if (cons? form)
                        (map (rcurry substitute-vars constraints) form)
                        form))
    (let (subst (find-constraint var constraints))
      (if (false? subst)
          subed-form
          (cons subed-form (constraint-right subst))))))

;;; Constraints

(def-struct! constraint left right)

(def-fun! find-constraint (key list)
  (if (empty? list)
      #f
      (if (eql? key (constraint-left (car list)))
          (car list)
          (find-constraint key (cdr list)))))

;;; Constraint generation

(def-fun! make-constraints (form decl &rest declared-type)
  (let (actual-form (car form)
        tv (cdr form))
    (if (not (cons? actual-form))
        (make-atom-constraints actual-form decl tv)
        (if (not (cons? (car (car actual-form))))
            (let (comb (eval (car (car actual-form)) decl))
              (cond
                (#t (make-combiner-constraints actual-form decl tv))))
            (make-combiner-constraints actual-form decl tv)))))

(def-fun! make-atom-constraints (atom decl tv)
  (list
   (make-constraint tv
                    (if ((disjoin number? boolean? keyword?) atom)
                        (make-enumeration-type atom)
                        (eval atom decl)))))

(def-fun! make-combiner-constraints (form decl tv)
  (destructuring-bind (comb &rest args) form
    (let* (comb-constraints (make-constraints comb decl)
           comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
      (append
       (list
        (make-constraint tv (arrow-type-return-type comb-type))
        (make-constraint (cdr comb) comb-type)
        (make-constraint (make-function-type (apply make-prod-type (map cdr args)) tv) comb-type))
       comb-constraints
       (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;;; Unification
(def-fun! unify-constraints (constraints)
  (let (clauses (make-empty-clauses))
    (map (lambda (constraint)
           (add-clause! (clause-from-constraint constraint)))
         clauses)
    ;; Unify now?
    ))

;; Prolog stuff

(def! p-subset (make-prolog-symbol "SUBSET"))
(def! p-enum (make-prolog-symbol "enum"))
(def! p-primitive (make-prolog-symbol "primitive"))
(def! p-intersection (make-prolog-symbol "intersection"))
(def! p-product (make-prolog-symbol "product"))
(def! p-sum (make-prolog-symbol "sum"))
(def! p-record (make-prolog-symbol "record"))
(def! p-tagged (make-prolog-symbol "tagged"))

(def-fun! clause-from-constraint (constraints)
  (make-clause (list p-subset
                     (type-to-prolog (constraint-left constraint))
                     (type-to-prolog (constraint-right constraint)))
               (list)))

(def-fun! type-to-prolog (type)
  (cond
    ((variable? type) type)
    ((enum-type? type) (apply (curry list p-enum) (enum-type-atoms type)))
    ((primitive-type? type) (list p-primitive (primitive-type-name type)))
    ((intersection-type? type) (apply (curry list p-intersection)
                                      (map type-to-prolog
                                           (intersection-type-types type))))
    ((product-type? type) (apply (curry list p-product)
                                 (map type-to-prolog
                                      (product-type-types type))))
    ((sum-type? type) (apply (curry list p-sum)
                             (map type-to-prolog
                                  (sum-type-types type))))
    ((record-type? type) (apply (curry list p-record)
                                (plist-map-values type-to-prolog
                                                  (record-type-alist type))))
    ((tagged-type? type) (list p-tagged (type-to-prolog (tagged-type-type type))))))

;; (def-fun! unify (constraints)
;;   (def-fun! unify-h (stack substs)
;;     (if (empty? stack)
;;         substs
;;         (let* (next (car stack)
;;                left (constraint-left next)
;;                right (constraint-right next))
;;           (cond
;;             ((type-equal? left right) (unify-h (cdr stack) substs))
;;             ((type-var? left) (unify-h
;;                                (substitute-constraints left rigth (cdr stack) :subtype)
;;                                (cons next (substitute-constraints left right substs :subtype))))
;;             ((type-var? right) (unify-h
;;                                 (substitute-constraints rigth left (cdr stack) :supertype)
;;                                 (cons next (substitute-constraints right left substs :supertype))))
;;             ((and? (type? left)
;;                    (type? right))
;;              (unify-h
;;               (append (unify-types left right) (cdr stack))
;;               substs))
;;             (#t (print "Can't unify!")
;;                 (print left)
;;                 (print right)
;;                 (list))))))
;;   (unify-h constraints (list)))

;; (def-fun! substitute-constraints (from to constraints relation)
;;   (map (lambda (constraint)
;;          (make-constraint
;;           (if (and? (eql? relation :subtype)
;;                     (eql? from (constraint-left constraint)))
;;               to
;;               (if (eql? relation :supertype)
;;                   (substitute-side from to (constraint-left constraint))
;;                   (constraint-left constraint)))
;;           (if (and? (eql? relation :supertype)
;;                     (eql? from (constraint-right constraint)))
;;               to
;;               (if (eql? relation :supertype)
;;                   (substitute-side from to (constraint-right constraint))
;;                   (constraint-right constraint)))))
;;        constraints))

;; (def-fun! substitute-side (from to side)
;;   (if (type? side)
;;       (substitute-type from to side)
;;       type))

;; (def-fun! substitute-type (from to type)
;;   (cond
;;     ((any? (lambda (pred) (pred type)) and-type? sum-type? prod-type?)
;;      ((type-constructor type)
;;       (map (curry substitute-type from to) (type-data-of type))))
;;     ((record-type? type)
;;      (substitute-record-type type))
;;     (#t type)))

;; (def-fun! unify-types (left right))

;; (def-fun! unify-types? (child parent)
;;   (cond
;;     ((enum-type? child)
;;      (enum-subset? child parent))
;;     ((pred-type? child)
;;      (pred-subset? child parent))
;;     ((and (and-type? child) (and-type? parent))
;;      (and-subset-and? child parent))
;;     ((and-type? child)
;;      (and-subset? child))
;;     (#t (print "Non-unifiable types!")
;;         (print child)
;;         (print parent)
;;         (list))))

;; ;; Subsetting enums
;; ;; (def-fun! enum-subset? (child parent)
;; ;;   (map (lambda (variant)
;; ;;          (make-constraint ())
;; ;;          ))
;; ;;   (all? (curry of-type? parent) (enum-type-variants child)))

;; ;; Subsetting for preds
;; (def-fun! pred-subset? (child parent)) ; No idea yet

;; ;; Subsetting for ands
;; (def-fun! and-subset-and? (child parent)
;;   (all?
;;    (lambda (type) (any? (rcurry is-subset? type) (and-type-types-of child)))
;;    (and-types-type-of parent))) ; So all parent predicates are subset of at least one child predicate

;; (def-fun! and-subset? (child parent)
;;   (any? (rcurry is-subset? parent) (and-type-types-of child))) ; So at least one predicate is a subset of a parent

;; ;; Subsetting for sums
;; (def-fun! sum-subset? (child parent)
;;   (map (rcurry make-constraint parent) (sum-type-types-of child)))

;; (def-fun! make-constraints (form decl &rest declared-type)
;;   (let (actual-form (car form)
;;         tv (cdr form))
;;     (if (not (cons? actual-form))
;;         (make-atom-constraints actual-form decl tv)
;;         (if (not (cons? (car (car actual-form))))
;;             (let (comb (eval (car (car actual-form)) decl))
;;               (cond
;;                 ((eql? comb :the-type) (make-the-constraints actual-form decl tv))
;;                 ((eql? comb :def-in!-type) (make-definer-constraints actual-form decl tv))
;;                 ((eql? comb :set-in!-type) (make-setter-constraints actual-form decl tv))
;;                 ((any? (curry eql? comb) (list :prod-type :op-type :fun-type)) (make-type-combiner-constraints actual-form decl tv))
;;                 ((eql? comb :cons-type) (if declared-type
;;                                             (make-declared-pair-constraints actual-form decl tv (car declared-type))
;;                                             (make-pair-constraints actual-form decl tv)))
;;                 ((eql? comb :lambda-type) (if declared-type
;;                                               (make-declared-lambda-constraints actual-form decl tv (car declared-type))
;;                                               (make-lambda-constraints actual-form decl tv)))
;;                 (#t (make-combiner-constraints actual-form decl tv))))
;;             (make-combiner-constraints actual-form decl tv)))))

;; (def-fun! make-atom-constraints (atom decl tv)
;;   (list
;;    (make-constraint tv
;;                (cond
;;                  ((number? atom) number)
;;                  ((boolean? atom) bool)
;;                  (#t (eval atom decl))))))

;; (def-fun! make-the-constraints (form decl tv)
;;   (destructuring-bind (_ type value) form
;;     (let* (type-constraints (make-constraints type decl)
;;            value-constraints (make-constraints value decl (normalize type decl)))
;;       (append
;;        (list
;;         (make-constraint tv (cdr value)))
;;        type-constraints
;;        value-constraints))))

;; (def-fun! make-definer-constraints (form decl tv)
;;   (destructuring-bind (_ env var value) form
;;     (let (value-constraints (make-constraints value decl)
;;           definer-env (eval (car env) decl))
;;       (def-in! definer-env symbol (cdr value))
;;       (append
;;        (list
;;         (make-constraint (cdr env) definer-env)
;;         (make-constraint (cdr var) symbol)
;;         (make-constraint tv (cdr var)))
;;        value-constraints))))

;; (def-fun! make-setter-constraints (form decl tv)
;;   (destructuring-bind (_ env var value) form
;;     (let (value-constraints (make-constraints value decl)
;;           setter-env (eval (car env) decl)
;;           var-type (eval (car var) decl))
;;       (append
;;        (list
;;         (make-constraint (cdr env) setter-env)
;;         (make-constraint (cdr var) symbol)
;;         (make-constraint tv (cer value))
;;         (make-constraint (cdr var) var-type))
;;        value-constraints))))

;; (def-fun! make-declared-pair-constraints (form decl tv declared-type)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint (cdr left) (tc-left declared-type))
;;       (make-constraint (cdr right) (if (eql? fun (tc-right declared-type))
;;                                         ((tc-right declared-type) (normalize left decl))
;;                                         (tc-right declared-type)))
;;       (make-constraint tv declared-type))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-declared-lambda-constraints (form decl tv declared-type))

;; (def-fun! make-pair-constraints (form decl tv)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint tv (prod (cdr left) (cdr right))))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-lambda-constraints (form decl tv)
;;   (destructuring-bind (_ lambda-list &rest body) form
;;     (let* (lambda-decl (make-env decl))
;;       (map (lambda (p) (dyn-def-in! lambda-decl (car p) (cdr p))) (car lambda-list))
;;       (append
;;        (list
;;         (make-constraint tv (fun (apply prod-list (map cdr (car lambda-list))) (cdr (last body)))))
;;        (reduce (lambda (prev next) (append (make-constraints next lambda-decl) prev)) (list) body)))))

;; (def-fun! make-type-combiner-constraints (form decl tv)
;;   (destructuring-bind (_ left right) form
;;     (append
;;      (list
;;       (make-constraint tv type)
;;       (make-constraint (cdr left) type)
;;       (make-constraint (cdr right) type))
;;      (make-constraints left decl)
;;      (make-constraints right decl))))

;; (def-fun! make-combiner-constraints (form decl tv)
;;   (destructuring-bind (comb &rest args) form
;;     (let* (comb-constraints (make-constraints comb decl)
;;            comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
;;       (append
;;        (list
;;         (make-constraint tv (tc-right comb-type))
;;         (make-constraint (cdr comb) comb-type)
;;         (make-constraint comb-type (fun (apply prod-list (map cdr args)) tv)))
;;        comb-constraints
;;        (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;; ;; Unification

;; (def-fun! unify (constraints)
;;   (def-fun! unify-h (stack substs)
;;     (if (empty? stack)
;;         substs
;;         (let* (next (car stack)
;;                left (constraint-left next)
;;                right (constraint-right next))
;;           (cond
;;             ((type-equal? left right) (unify-h (cdr stack) substs))
;;             ((type-var? left) (unify-h
;;                                (substitute-constraints next (cdr stack))
;;                                (cons next (substitute-constraints next substs))))
;;             ((type-var? right) (unify-h
;;                                 (cons (make-constraint right left) (cdr stack))
;;                                 substs))
;;             ((and? (tc? left)
;;                    (tc? right))
;;              (unify-h
;;               (append (unify-tc left right) (cdr stack))
;;               substs))
;;             (#t (print "Can't unify!")
;;                 (print left)
;;                 (print right)
;;                 (list))))))
;;   (unify-h constraints (list)))

;; (def-fun! unify-tc (left right)
;;   (list
;;    (make-constraint (tc-left left) (tc-left right))
;;    (make-constraint (tc-right left) (tc-right right))))

;; (def-fun! substitute-constraints (subst constraints)
;;   (map (lambda (constraint)
;;          (make-constraint
;;           (substitute-side subst (constraint-left constraint))
;;           (substitute-side subst (constraint-right constraint))))
;;        constraints))

;; (def-fun! substitute-side (subst side)
;;   (cond
;;     ((eql? side (constraint-left subst)) (constraint-right subst))
;;     ((tc? side) ((tc-constructor-fun side)
;;                  (substitute-side subst (tc-left side))
;;                  (substitute-side subst (tc-right side))))
;;     (#t side)))

;; (def-op! check-op env (form type decl)
;;   (check form type (eval decl env)))

;; (def-fun! check (form type decl)
;;   (let (type (infer type decl))
;;     (if (not? (cons? form))
;;         (type-equal? type (infer form decl))
;;         (let (comb (eval (car form) decl))
;;           (cond
;;             ((eql? comb :cons-type) (check-pair form type decl))
;;             ((eql? comb :lambda-type) (check-lambda form type decl)) ;; Should be vau
;;             (#t (type-equal? type (infer form decl))))))))

;; (def-fun! check-type-constructor (left right type decl)
;;   (let (left-value (normalize left decl))
;;     (and?
;;      (check left-value (tc-left type) decl)
;;      (check right-value ((tc-rigth type) left-value) decl))))

;; (def-fun! check-pair (form type decl)
;;   (destructuring-bind (_ left right) form
;;     (check-type-constructor left right type decl)))

;; (def-fun! check-lambda (form type decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - &rest handling
;;     (check-type-constructor (car lambda-list) body))) ;; TODO - should handle multi-argument lambda-lists

;; (def-op! infer-op env (form decl)
;;   (infer form (eval decl env)))

;; (def-fun! infer (form decl)
;;   (if (not? (cons? form))
;;       (infer-atom form decl)
;;       (let (comb (eval (car form) decl))
;;        (cond
;;          ((eql? comb :declare-type) (infer-annotation form decl))
;;          ((some? (curry eql? comb) (list :prod-type :op-type :fun-type)) (infer-type-combiner form decl))
;;          ((eql? comb :cons-type) (infer-pair form decl))
;;          ((eql? comb :lambda-type ) (infer-lambda form decl))
;;          (#t (infer-comb form decl))))))

;; (def-fun! infer-atom (atom decl)
;;   (cond
;;     ((number? atom) number)
;;     ((boolean? atom) bool)
;;     (#t (eval atom decl))))

;; (def-fun! infer-annotation (form decl)
;;   (destructuring-bind (_ symbol value) form
;;     (if (check value type decl)
;;         (do
;;          (dyn-def-in! decl symbol (infer value decl))
;;          bool)
;;         #f)))

;; (def-fun! infer-type-combiner (form decl)
;;   (destructuring-bind (_ left right) form
;;     (if (and?
;;          (check left type decl)
;;          (or?
;;           (check right type decl)
;;           (check right (fun left type) decl)))
;;         type
;;         #f)))

;; (def-fun! infer-pair (form decl)
;;   (destructuring-bind (_ left right) form
;;     (prod (infer left decl) (infer right decl))))

;; (def-fun! infer-lambda (form decl)
;;   (destructuring-bind (_ lambda-list body) form ;; TODO - should handle &rest for body
;;     (let (lambda-decl (make-env decl)
;;           type-variables (make-type-variable-list (length lambda-list)))
;;       (map (lambda (p) (extend lambda-decl (car p) (cdr p)))
;;            (zip (lambda-list) type-variables))
;;       (fun (apply prod-list type-combiner) (infer body lambda-decl)))))

;; (def-fun! infer-comb (form decl)
;;   (destructuring-bind (comb arg) form ;; TODO should handle multi-argument functions and should handle vau
;;     (let (comb-type (infer comb decl)
;;                     arg-type (infer arg decl))
;;       (if (check (tc-left comb-type) arg-type decl)
;;           (tc-right comb-type)
;;           #f))))