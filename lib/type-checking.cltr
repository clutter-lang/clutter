;;;; Inference

;;; Entry level

(def-op! infer-code env (code decl)
  (let (ast (print (mark-ast code)))
    (print "Constraints:")
    (substitute-vars ast (print (unify-constraints (print (make-constraints ast (eval decl env))))))))

;;; AST marking

(def-struct! variable name)

(def-fun! mark-ast (ast)
  (let (counter 0)
    (letrec (mark-ast-helper
             (lambda (ast)
               (let (current counter)
                 (set! counter (+ counter 1))
                 (cons (if (cons? ast)
                           (map mark-ast-helper ast)
                           ast)
                       (make-variable current)))))
      (mark-ast-helper ast))))

(def-fun! substitute-vars (ast constraints)
  (let* (form (car ast)
         var (cdr ast)
         subed-form (if (cons? form)
                        (map (rcurry substitute-vars constraints) form)
                        form))
    (let (subst (find-constraint var constraints))
      (if (false? subst)
          subed-form
          (cons subed-form (constraint-right subst))))))

;;; Constraints

(def-struct! constraint left right)

(def-fun! find-constraint (key list)
  (if (empty? list)
      #f
      (if (eql? key (constraint-left (car list)))
          (car list)
          (find-constraint key (cdr list)))))

;;; Constraint generation

(def-fun! make-constraints (form decl &rest declared-type)
  (let (actual-form (car form)
        tv (cdr form))
    (if (not (cons? actual-form))
        (make-atom-constraints actual-form decl tv)
        (if (not (cons? (car (car actual-form))))
            (let (comb (eval (car (car actual-form)) decl))
              (cond
                (#t (make-combiner-constraints actual-form decl tv))))
            (make-combiner-constraints actual-form decl tv)))))

(def-fun! make-atom-constraints (atom decl tv)
  (list
   (make-constraint tv
                    (if ((disjoin number? boolean? keyword?) atom)
                        (make-literal-type atom)
                        (eval atom decl)))))

(def-fun! make-combiner-constraints (form decl tv)
  (destructuring-bind (comb &rest args) form
    (let* (comb-constraints (make-constraints comb decl)
           comb-type (constraint-right (find-constraint (cdr comb) comb-constraints)))
      (append
       (list
        (make-constraint (make-product-type (map cdr args)) (arrow-type-from comb-type))
        (make-constraint tv (arrow-type-to comb-type)))
       comb-constraints
       (reduce (lambda (prev next) (append (make-constraints next decl) prev)) (list) args)))))

;;; Unification

; lowercase for vars, upper case for types
; for each x\T
; A <: B => (x\T)A <: B if (x\T)A <: A
; A <: B => A <: (x\T)B if B <: (x\T)B
; x <: T => A <: (x\T)A
; T <: x => (x\T)A <: A

(def-fun! substitute-constraints (from to list)
  (map (lambda (constraint)
         (make-constraint (substitute-type from to :subtype (constraint-left constraint))
                          (substitute-type from to :supertype (constraint-right constraint))))
       list))

(def-fun! complement-substitution-kind (kind)
  (if (eql? kind :supertype)
      :subtype
      :supertype))

(def-fun! substitute-type (from to kind type)
  (cond
    ((and? (eql? from type)
           (eql? kind :supertype))
     to)
    ((product-type? type)
     (make-product-type
      (map (curry substitute-type from to kind)
           (product-type-types type))))
    ((arrow-type? type)
     (make-arrow-type (substitute-type from to (complement-substitution-kind kind)
                                       (arrow-type-from type))
                      (substitute-type from to kind
                                       (arrow-type-to type))))
    (#t type)))

(def-fun! unify-constraints (constraints)
  (def-fun! unify-h (stack substs)
    (print "Next step")
    (print stack)
    (print substs)
    (if (empty? stack)
        substs
        (let* (next (car stack)
               child (constraint-left next)
               parent (constraint-right next))
          (cond
            ((eql? child parent) (unify-h (cdr stack) substs))
            ((variable? child)
             (let (subs (curry substitute-constraints child parent))
               (unify-h
                (subs (cdr stack))
                (cons next (subs substs)))))
            ((and? (type? child)
                   (type? parent))
             (let (result (unify-types child parent))
               (when result
                 (unify-h (append (cdr stack) result)
                          substs))))))))
  (unify-h constraints (list)))

(def-fun! unify-types (child parent)
  (cond
    ((and? (literal-type? child)
           (literal-type? parent))
     (unify-literals child parent))
    ((literal-type? child)
     (unify-literal-child child parent))
    ((and? (primitive-type? child)
           (primitive-type? parent))
     (unify-primitives child parent))
    ((and? (product-type? child)
           (product-type? parent))
     (unify-products child parent))
    ((and (arrow-type? child)
          (arrow-type? parent))
     (unify-arrows child parent))))

(def-fun! unify-literals (child parent)
  ;; This is fail only unifier, equal literals just eliminate
  (list
   (make-constraint (literal-type-atom child)
                    (literal-type-atom parent))))

(def-fun! unify-literal-child (child parent)
  (cond
    ((primitive-type? parent) (make-constraint (atom-primitive-type (literal-type-atom child))
                                               parent))))

(def-fun! unify-primitives (child parent)
  ;; This is fail only unifier, equal primitives just eliminate
  (list
   (make-constraint (primitive-type-name child)
                    (primitive-type-name parent))))

(def-fun! unify-products (child parent)
  (let (child-types (product-type-types child)
        parent-types (product-type-types parent))
    (when (eql? (length child-types)
                (length parent-types))
      (map make-constraint
           child-types
           parent-types))))

(def-fun! unify-arrows (child parent)
  (list
   (make-constraint (arrow-type-from parent) (arrow-type-from child))
   (make-constraint (arrow-type-to child) (arrow-type-to parent))))
