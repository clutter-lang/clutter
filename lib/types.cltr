;;;; Types

;;; Concrete types

(def-struct! literal-type atom)

(def-struct! primitive-type name)

(def-struct! operative-type from to)

(def-struct! function-type from to)

(def-fun! make-arrow-type (original-type from to)
  (if (operative-type? original-type)
      (make-operative-type from to)
      (make-function-type from to)))

(def-fun! arrow-type-from (type)
  (if (operative-type? type)
      (operative-type-from type)
      (operative-type-from type)))

(def-fun! arrow-type-to (type)
  (if (operative-type? type)
      (operative-type-to type)
      (operative-type-to type)))

(def! arrow-type? (disjoin operative-type?
                           function-type?))

(def-struct! product-type types)

(def-struct! intersection-type types)

(def-struct! union-type types)

(def-struct! variant-type types)

(def-struct! record-type types)

(def-fun! labeled-type-types (type)
  (if (variant-type? type)
      (variant-type-types type)
      (record-type-types type)))

(def-fun! labeled-type-labels (type)
  (plist-keys (labeled-type-types type)))

(def-fun! labeled-type-values (type)
  (plist-values (labeled-type-types type)))

(def-fun! labeled-type-get (label type)
  (plist-get label (labeled-type-types type)))

(def-struct! rec-type variable type)

(def-fun! unroll-type (with rec-type)
  (substitute-type (rec-type-variable rec-type) with :supertype (rec-type-type rec-type)))

(def-fun! roll-type (with type variable)
  (make-rec-type variable
                 (substitute-type with variable :supertype type)))

(def! top :top)
(def! bottom :bottom)

(def! top? (curry eql? top))
(def! bottom? (curry eql? bottom))

(def! type? (disjoin literal-type?
                     primitive-type?
                     arrow-type?
                     product-type?
                     intersection-type?
                     union-type?
                     variant-type?
                     record-type?))

(def-fun! get-type-constructor (type)
  (pred-case type
   (literal-type? make-literal-type)
   (primitive-type? make-primitive-type)
   (arrow-type? (curry make-arrow-type type))
   (product-type? make-product-type)
   (intersection-type? make-intersection-type)
   (union-type? make-union-type)
   (variant-type? make-variant-type)
   (record-type? make-record-type)
   (rec-type? make-rec-type)))

(def-fun! atom-primitive-type (atom)
  (pred-case atom
   (number? (make-primitive-type "number"))
   (boolean? (make-primitive-type "boolean"))))

(def-fun! type-order? (left right)
  (letseq (type-list (list variable?
                        literal-type?
                        primitive-type?
                        rec-type?
                        product-type?
                        arrow-type?
                        variant-type?
                        record-type?
                        intersection-type?
                        union-type?)
           type-is (lambda (type fn) (fn type))
           types (list left right)
           all? (rcurry all? types))
    (cond
      ((all? variable?)
       (string<? (keyword-name (variable-name left))
                 (keyword-name (variable-name right))))
      ((all? literal-type?) #t)
      ((all? rec-type?) (type-order? (rec-type-type left)
                                     (rec-type-type right)))
      ((all? product-type?) (sequence-order? type-order?
                                             (product-type-types left)
                                             (product-type-types right)))
      ((all? arrow-type?) (sequence-order? type-order?
                                           (list (arrow-type-from left)
                                                 (arrow-type-to left))
                                           (list (arrow-type-from right)
                                                 (arrow-type-to right))))
      ((all? variant-type?) (sort-labeled-types left right))
      ((all? record-type?) (sort-labeled-types left right))
      ((all? intersection-type?) (sequence-order? type-order?
                                                  (intersection-type-types left)
                                                  (intersection-type-types right)))
      ((all? union-type?) (sequence-order? type-order?
                                           (union-type-types left)
                                           (union-type-types right)))
      ; General case
      (#t (<? (position #t (map (curry type-is left) type-list))
              (position #t (map (curry type-is right) type-list)))))))

(def-fun! sort-labeled-types (left right)
  (or (sequence-order? (compose string<? keyword-name)
                       (labeled-type-labels left)
                       (labeled-type-labels right))
      (sequence-order? type-order?
                       (labeled-type-values left)
                       (labeled-type-values right))))

(def! labeled-type? (disjoin record-type? union-type?))

(def! group-type? (disjoin intersection-type? union-type?))

(def-fun! normalize-group-type (type)
  (def-fun! normalize-helper (type constructor accessor indicator)
    (def-fun! normalize-helper-recur (n types)
      (if (<? n 0)
          types
          (if (any? (curry indicator (car types)) (cdr types))
              (normalize-helper-recur (- n 2) (cdr types))
              (normalize-helper-recur (- n 1) (append (cdr types) (list (car types)))))))
    (letseq (types (accessor type)
             normalized (normalize-helper-recur (length types) types))
            (if (eql? (length normalized) 1)
                (car normalized)
                (constructor normalized))))
  (if (union-type? type)
      (normalize-helper type make-union-type union-type-types subtype?)
      (normalize-helper type make-intersection-type intersection-type-types supertype?)))

(def-fun! subtype? (child parent)
  (cond
    ((or? (bottom? child)
          (top? parent))
     #t)
    ((or? (and? (literal-type? child)
                (literal-type? parent))
          (and? (primitive-type? child)
                (primitive-type? parent)))
     (eql? child parent))
    ((and? (literal-type? child)
           (primitive-type? parent))
     (subtype? (atom-primitive-type (literal-type-atom child))
               parent))
    ((and? (rec-type? child)
           (rec-type? parent))
     (subtype? (rec-type-type child)
               (rec-type-type parent)))
    ((and? (arrow-type? child)
           (arrow-type? parent))
     (and? (subtype? (arrow-type-from parent)
                     (arrow-type-from child))
           (subtype? (arrow-type-to child)
                     (arrow-type-to parent))))
    ((and? (product-type? child)
           (product-type? parent))
     (let (child-types (product-type-types child)
           parent-types (product-type-types parent))
       (and? (eql? (length child-types)
                   (length parent-types))
             (all? subtype? child-types parent-types))))
    ((and? (variant-type? child)
           (variant-type? parent))
     (all? (lambda (label)
             (subtype? (labeled-type-get label child)
                       (labeled-type-get label parent)))
           (labeled-type-labels child)))
    ((and? (record-type? child)
           (record-type? parent))
     (all? (lambda (label)
             (subtype? (labeled-type-get label child)
                       (labeled-type-get label parent)))
           (labeled-type-labels parent)))
    ((union-type? child)
     (all? (curry supertype? parent) (union-type-types child)))
    ((union-type? parent)
     (any? (curry subtype? child) (union-type-types? parent)))
    ((intersection-type? child)
     (any? (curry supertype? parent) (intersection-type-types child)))
    ((intersection-type? parent)
     (all? (curry subtype? child) (intersection-type-types parent)))))

(def-fun! supertype? (parent child)
  (subtype? child parent))