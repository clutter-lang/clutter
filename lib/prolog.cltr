;;;;; Prolog for typechecking in Clutter. Inspired by Peter Norvig's one.

;;;; Unifier
;;; Variables

(def-struct! variable name)

;;; Bindings

(def-struct! binding var value)

(def-fun! make-empty-bindings ()
  (list))

(def-fun! get-binding (var bindings)
  (assoc-by (lambda (key binding) (eql? key (binding-var binding))) var bindings))

(def-fun! in-bindings? (var bindings)
  (not-false? (get-binding var bindings)))

(def-fun! lookup-binding (var bindings)
  (binding-value (get-binding var bindings)))

(def-fun! extend-bindings (var value bindings)
  (cons (make-binding var value) bindings))

;;; Unification

(def-fun! unify (x y bindings)
  (cond
    ((false? bindings) #f)
    ((eql? x y) bindings)
    ((variable? x) (unify-variable x y bindings))
    ((variable? y) (unify-variable y x bindings))
    ((and? (list? x) (list? y))
     (unify (rest x) (rest y)
            (unify (first x) (first y) bindings)))
    (#t #f)))

(def-fun! unify-variable (var x bindings)
  (cond
    ((in-bindings? var bindings)
     (unify (lookup-binding var bindings) x bindings))
    ((and? (variable? x) (in-bindings? x bindings))
     (unify var (lookup-binding x bindings) bindings))
    ((occurs-again? var x bindings)
     #f)
    (#t (extend-bindings var x bindings))))

(def-fun! occurs-again? (var x bindings)
  (cond
    ((eql? var x) #t)
    ((and? (variable? x) (in-bindings? x bindings))
     (occurs-again? var (lookup-binding x bindings) bindings))
    ((and? (not (variable? x)) (list? x))
     (or? (occurs-again? var (first x) bindings)
          (occurs-again? var (rest x) bindings)))
    (#t #f)))

;;; Substitution

(def-fun! subst-bindings (bindings x)
  (cond
    ((false? bindings) #f)
    ((empty? bindings) x)
    ((and? (variable? x) (in-bindings? x bindings))
     (subst-bindings bindings (lookup-binding x bindings)))
    ((or? (atom? x) (null? x)) x)
    ((list? x) (cons (subst-bindings bindings (car x))
                     (subst-bindings bindings (cdr x))))
    (#t #f)))

(def-fun! unifier (x y)
  (subst-bindings (unify x y (make-empty-bindings)) x))

;;;; Prologue as it is

;;; Clauses

(def-struct! clause head body)

(def-fun! clause-as-tree (clause)
  (list (clause-head clause) (clause-body clause)))

(def-fun! clause-from-tree (tree)
  (make-clause (first clause) (second clause)))

(def-fun! predicate (relation)
  (first relation))

(def-fun! args (relation)
  (rest relation))

(def-fun! make-empty-clauses ()
  (make-env))

(def-fun! get-clauses (pred clauses)
  (eval pred clauses))

(def-fun! in-clauses? (pred clauses)
  (bound? pred clauses))

(def-fun! set-clauses! (pred value clauses)
  ((if (in-clauses? pred clauses)
       dyn-set-in!
       dyn-def-in!)
   clauses pred value))

(def-fun! add-clause! (clause clauses)
  (let (pred (predicate (clause-head clause))
        prev (list))
    (when (in-clauses? pred clauses)
      (set! prev (get-clauses pred clauses)))
    (set-clauses! pred (append prev (list clause)) clauses)))

(def-fun! remove-predicate! (pred clauses)
  (forget-in! clauses pred))

(def-fun! create-variables (list)
  (map-tree (lambda (el) (if (keyword? el)
                             (make-variable (keyword-name el))
                             el))
            list))

(def-op! <- env (clauses &rest clause)
  (let (new-clause (create-variables clause))
    (add-clause! (make-clause (first new-clause) (rest new-clause))
                 (eval clauses env))))

(def-op! ?- env (clauses &rest goals)
  (prove-all (create-variables goals) (make-empty-bindings) (eval clauses env)))

(def-fun! replace-in-clause (alist clause)
  (let (new-tree (replace-in-tree alist
                                  (list (clause-head clause)
                                        (clause-body clause))))
    (make-clause (first new-tree) (second new-tree))))

(def-fun! variables-in (clause)
  (remove-duplicates (filter variable?
                             (apply append (clause-as-tree clause)))))

;;; Variable utilities

(def-fun! rename-variables (clause)
  (replace-in-clause (map (lambda (var)
                                    (cons var (make-variable (symbol-name (gensym (variable-name var))))))
                          (variables-in clause))
                   clause))

(def-fun! prove-all (goals bindings clauses)
  (cond
    ((false? bindings) (list))
    ((empty? goals) bindings)
    (#t (map (lambda (goal1-solution)
               (prove-all (rest goals) goal1-solution clauses))
             (prove (first goals) bindings clauses)))))

(def-fun! prove (goal bindings all-clauses)
  (map-append (lambda (clause)
                (let (new-clause (rename-variables clause))
                  (prove-all (clause-body new-clause)
                             (unify goal (clause-head new-clause) bindings)
                             all-clauses)))
              (get-clauses (predicate goal) all-clauses)))