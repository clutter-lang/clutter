(def-in! ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def-in! (get-current-env) global-env
  (get-current-env))

(def-in! global-env def!
  (vau env (var value)
    (eval (list def-in! env var value) env)))

(def-in! global-env set!
  (vau env (var value)
    (eval (list set-in! env var value) env)))

(def! def-op!
  (vau env (name env-var vau-list &rest body)
    (eval (list def! name (list* vau env-var vau-list body)) env)))

(def-op! lambda env (vau-list &rest body)
  (wrap (eval (list* vau () vau-list body) env)))

(def-op! def-fun! env (name lambda-list &rest body)
  (eval (list def! name (list* lambda lambda-list body)) env))

(def-op! lookup env (var lookup-env)
  (eval var (eval lookup-env env)))

(def-fun! map (function values)
  (if (eql? (list) values)
      (list)
      (cons (function (car values)) (map function (cdr values)))))

(def-op! do env (&rest body)
  (let ((last-value ()))
    (map (lambda (exp) (set! last-value (eval exp env)))
         body)
    last-value))

(def-op! cond env (&rest forms)
  (if (eql? forms ())
      #f
      (if (eval (car (car forms)) env)
          (eval (list* do (cdr (car forms)))
                env)
          (eval (list* cond (cdr forms)) env))))

(def-fun! assoc (key alist)
  (if (eql? alist (list))
      #f
      (if (eql? key (car (car alist)))
          (car alist)
          (assoc key (cdr alist)))))

(def-op! let env (clauses &rest body)
  (eval (list* (list* lambda (map car clauses) body)
               (map (lambda (x) (car (cdr x))) clauses))
        env))

(def-op! when env (test &rest body)
  (if (eval test env)
      (eval (list* do body) env)
      #f))

(def-op! unless env (test &rest body)
  (if (eval test env)
      #f
      (eval (list* do body) env)))

(def-op! returning env (first &rest body)
  (let ((return-val (eval first env)))
    (map (curry eval env) body)
    return-val))

(def-op! push! env (value place)
  (eval (list set! place (list cons value place))
        env))

(def-fun! curry (function &rest first-args)
  (lambda (&rest last-args)
    (apply function (append first-args last-args))))

(def-fun! rcurry (function &rest last-args)
  (lambda (&rest first-args)
    (apply function (append first-args last-args))))

(def-fun! first (sequence)
  (car sequence))

(def-fun! rest (sequence)
  (cdr sequence))

(def-op! or? env (&rest values)
  (if (=? (length values) 0)
      #f
      (let ((result (eval (first values) env)))
        (if result
            result
            (eval (list* or? (rest values)) env)))))

(def-op! and? env (&rest values)
  (if (=? (length values) 0)
      #t
      (let ((result (eval (first values) env)))
        (if result
            (eval (list* and? (rest values)) env)
            #f))))

(def-fun! every? (predicate sequence)
  (if (eql? sequence (list))
      #t
      (and? (predicate (first sequence))
            (every? predicate (rest sequence)))))

(def-fun! sequence? (object)
  (list? object))

(def-fun! combiner? (object)
  (or? (function? object)
       (operator? object)))

(def-fun! apply (function args)
  (eval (cons (unwrap function) args) (get-current-env)))

(def-op! with-env callsite-env (target-env &rest body)
  (eval (list* do body) (eval target-env callsite-env)))

(def-op! module dyn-env (parent-envs &rest body)
  (let ((env (apply make-env (map (rcurry eval dyn-env) parent-envs))))
    (map (rcurry eval env) body)
    env))

(def-op! provide! dyn-env (bindings parent-envs &rest body)
  (let ((module-env (eval (list* module parent-envs body) dyn-env)))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding module-env)) dyn-env))
         bindings))
  bindings)

(def-op! providing-module dyn-env (bindings parent-envs &rest body)
  (eval (list module (list)
              (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                     body))
        dyn-env))

(def-op! import-from! dyn-env (from-env &rest bindings)
  (let ((env (eval from-env dyn-env)))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding env)) dyn-env))
         bindings))
  bindings)

(def! anaphora
  (module (global-env)

    (def-op! anaphoric env (op var test &rest body)
      (eval (list let (list (list var (eval test env)))
                  (list* op var body))
            env))

    (def-op! aif env (var test then else)
      (eval (list anaphoric if var test then else) env))

    (def-op! awhen env (var test &rest body)
      (eval (list* anaphoric when var test body) env))

    (def-op! aunless env (var test &rest body)
      (eval (list* anaphoric unless var test body) env))

    (def-op! areturning env (var first &rest body)
      (eval (list* anaphoric returning var first body) env))

    ))
