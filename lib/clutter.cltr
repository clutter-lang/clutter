(def-const-in! ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def-const-in! (get-current-env) global-env
  (get-current-env))

(def-const-in! (get-current-env) empty-env
  (make-env))

(def-const-in! global-env def!
  (vau env (var value)
    (eval (list def-in! env var value) env)))

(def-const-in! global-env def-const!
  (vau env (var value)
    (eval (list def-const-in! env var value) env)))

(def-const-in! global-env set!
  (vau env (var value)
    (eval (list set-in! env var value) env)))

(def-const! def-op!
 (vau env (name env-var vau-list &rest body)
   (eval (list def! name
               (list* nvau name env-var vau-list body))
         env)))

(def-const! def-const-op!
 (vau env (name env-var vau-list &rest body)
   (eval (list def-const! name
               (list* nvau name env-var vau-list body))
         env)))

(def-const-op! dyn-def-in! dyn-env (env var value)
  (eval (list def-in!
              (list (unwrap eval) env dyn-env)
              (eval var dyn-env)
              (list (unwrap eval) value dyn-env))
        dyn-env))

(def-const-op! dyn-set-in! dyn-env (env var value)
    (eval (list set-in!
                (list (unwrap eval) env dyn-env)
                (eval var dyn-env)
                (list (unwrap eval) value dyn-env))
          dyn-env))

(def-const-op! lambda env (vau-list &rest body)
  (wrap (eval (list* vau #ignore vau-list body) env)))

(def-const-op! nlambda env (name vau-list &rest body)
  (wrap (eval (list* nvau name #ignore vau-list body) env)))

(def-const! fun-name
  (lambda (f)
    (vau-name (unwrap f))))

(def-const-op! def-fun! env (name lambda-list &rest body)
  (eval (list def! name
              (list* nlambda name lambda-list body))
        env))

(def-const-op! def-const-fun! env (name lambda-list &rest body)
  (eval (list def-const! name
              (list* nlambda name lambda-list body))
        env))

(def-const-op! lookup env (var lookup-env)
  (eval var (eval lookup-env env)))

(def-const-fun! map1 (function values)
  (if (empty? values)
      (list)
      (cons (function (car values)) (map function (cdr values)))))

(def-const-fun! apply1 (function args)
  (eval (cons (unwrap function) args) (get-current-env)))

(def-const-fun! apply (function &rest args)
  (eval (list* (unwrap function) (append (butlast args 1) (last args)))
        empty-env))

(def-const-fun! zip (&rest sequences)
  (if (empty? (first sequences))
      (list)
      (list* (map1 first sequences) (apply zip (map1 rest sequences)))))

(def-const-fun! curry (function &rest first-args)
  (nlambda curried (&rest last-args)
    (apply1 function (append first-args last-args))))

(def-const-fun! rcurry (function &rest last-args)
  (nlambda curried (&rest first-args)
    (apply1 function (append first-args last-args))))

(def-const-fun! map (function &rest lists)
  (map1 (curry apply1 function) (apply zip lists)))

(def-const-fun! reduce (function initial values)
  (if (empty? values)
      initial
      (function initial (reduce function (car values) (cdr values)))))

(def-const-fun! flatten (sequence)
  (reduce append (list) sequence))

(def-const-fun! constantly (value)
  (lambda (&rest #ignore) value))

(def-const-op! destructuring-bind dyn-env (vau-list values &rest body)
  (let (env (make-env dyn-env))
    (def-fun! perform-binding (vau-list values)
      (cond
        ((empty? vau-list) #t)
        ((eql? (first vau-list) ((vau #ignore (x) x) &rest))
         (dyn-def-in! env (second vau-list) values))
        (#t
         (dyn-def-in! env (first vau-list) (first values))
         (perform-binding (rest vau-list) (rest values)))))

    (perform-binding vau-list (eval values dyn-env))
    (eval (cons do body) env)))

(def-const-op! do env (&rest body)
  (if (eql? (length body) 1)
      (eval (first body) env)
      (eval (list (list* vau #ignore () body)) env)))

(def-const-op! cond env (&rest forms)
  (if (empty? forms)
      #f
      (if (eval (car (car forms)) env)
          (eval (list* do (cdr (car forms))) env)
          (eval (list* cond (cdr forms)) env))))

(def-const-fun! assoc (key alist)
  (if (eql? alist (list))
      #f
      (if (eql? key (car (car alist)))
          (car alist)
          (assoc key (cdr alist)))))

(def-const-fun! not (value)
  (if value #f #t))
(def-const! false? not)

(def-const! null? (curry eql? (list)))

(def-const-fun! compose (function &rest more-functions)
  (reduce (lambda (f g)
            (lambda (&rest args)
              (f (apply g args))))
          function
          more-functions))

(def-const-fun! conjoin (&rest predicates)
  (def-fun! conjunction (predicates value)
    (if (empty? predicates)
        #t
        (and? ((first predicates) value)
              (conjunction (rest predicates) value))))
  (curry conjunction predicates))

(def-const-fun! disjoin (&rest predicates)
  (def-fun! disjunction (predicates value)
    (if (empty? predicates)
        #f
        (or? ((first predicates) value)
             (conjunction (rest predicates) value))))
  (curry disjunction predicates))

(def-const! complement (curry compose not))

(def-const! empty? null?)

(def-const-fun! filter (predicate sequence)
  (if (empty? sequence)
      (list)
      (if (predicate (first sequence))
          (cons (first sequence) (filter predicate (rest sequence)))
          (filter predicate (rest sequence)))))


(def-const! first car)
(def-const! rest cdr)
(def-const-fun! nth (n sequence)
  (def-fun! rec (n seq)
    (if (<=? n 0)
        (car seq)
        (rec (- n 1) (cdr seq))))
  (rec n sequence))
(def-const! second (curry nth 1))
(def-const! third (curry nth 2))
(def-const! fourth (curry nth 3))
(def-const! fifth (curry nth 4))
(def-const! sixth (curry nth 5))
(def-const! seventh (curry nth 6))
(def-const! eighth (curry nth 7))
(def-const! ninth (curry nth 8))
(def-const! tenth (curry nth 9))

(def-const-fun! last (seq)
  (def! remainder (rest seq))
  (if (empty? remainder)
      (first seq)
      (last remainder)))

(def-const-fun! butlast (seq n)
  (if (>=? n (length seq))
      (list)
      (cons (first seq) (butlast (rest seq) n))))

(def-const-fun! even? (number)
  (=? (rem number 2) 0))

(def-const! odd? (complement even?))

(def-const-op! inc! env (var)
  (eval (list set! var (list + 1 var)) env))

(def-const-op! dec! env (var)
  (eval (list set! var (list - var 1)) env))

(def-const-op! let env (clauses &rest body)
  (eval (list*
         (list* lambda
                (filter ((lambda (x) (lambda (#ignore) (odd? (inc! x)))) 0)
                        clauses)
                body)
         (filter ((lambda (x) (lambda (#ignore) (even? (inc! x)))) 0)
                 clauses))
        env))

(def-const-op! letseq dyn-env (bindings &rest body)
  (let (env (make-env dyn-env))
    (if (null? bindings)
        (eval (cons do body) env)
        (do
         (dyn-def-in! env (car bindings) (eval (car (cdr bindings)) dyn-env))
         (eval (list* letseq (cdr (cdr bindings)) body) env)))))

(def-const-op! letrec dyn-env (bindings &rest body)
  (letseq (vars (filter (let (x 0) (lambda (#ignore) (odd? (inc! x)))) bindings)
           values (filter (let (x 0) (lambda (#ignore) (even? (inc! x)))) bindings)
           def-forms (cons do (map (lambda (var val) (list def! var val)) vars values)))
    (eval (list* let ()
                 def-forms
                 body)
          dyn-env)))

(def-const-op! letrecseq dyn-env (bindings &rest body)
  (eval (if (null? bindings)
            (list* letrec bindings body)
            (list letrec
                  (list (car bindings) (car (cdr bindings)))
                  (list* letrecseq (cdr (cdr bindings)) body)))
        dyn-env))

(def-const-op! when env (test &rest body)
  (if (eval test env)
      (eval (list* do body) env)
      #f))

(def-const-op! unless env (test &rest body)
  (if (eval test env)
      #f
      (eval (list* do body) env)))

(def-const-op! returning env (first &rest body)
  (let (return-val (eval first env))
    (map (rcurry eval env) body)
    return-val))

(def-const-op! push! env (value place)
  (eval (list set! place (list cons value place))
        env))

(def-const-op! or? env (&rest expressions)
  (if (=? (length expressions) 0)
      #f
      (let (result (eval (first expressions) env))
        (if result
            result
            (eval (list* or? (rest expressions)) env)))))

(def-const-op! and? env (&rest expressions)
  (if (=? (length expressions) 0)
      #t
      (let (result (eval (first expressions) env))
        (if result
            (eval (list* and? (rest expressions)) env)
            #f))))

(def-const-fun! all? (predicate sequence)
  (apply (wrap and?) (map predicate sequence)))

(def-const-fun! any? (predicate sequence)
  (apply (wrap or?) (map predicate sequence)))

(def-const! sequence? list?)

(def-const-fun! call (function &rest args)
  (apply function args))

(def-const-fun! combiner? (object)
  (any? (rcurry call object) (list function? operative?)))

(def-const-fun! member? (item sequence)
  (if (>? (length sequence) 0)
      (if (eql? item (first sequence))
          sequence
          (member? item (rest sequence)))
      #f))

;;; Depth-first
(def-const-fun! map-tree (pred tree)
  (if (sequence? tree)
      (map (curry map-tree pred) tree)
      (pred tree)))

(def-const-op! case env (value &rest clauses)
  (def! actual-value (eval value env))
  (def-fun! process-clauses (clauses)
    (if (empty? clauses)
        #f
        (let (clause (first clauses))
          (if (or? (eql? (first clause) #t)
                   (eql? (eval (first clause) env)
                         actual-value))
              (eval (cons do (rest clause)) env)
              (process-clauses (rest clauses))))))
  (process-clauses clauses))

(def-const-op! pred-case env (value &rest clauses)
  (def! actual-value (eval value env))
  (def! pred-env (make-env env))
  (def-in! pred-env otherwise (constantly #t))
  (def-fun! process-clauses (clauses)
    (if (empty? clauses)
        #f
        (let (clause (first clauses))
          (if ((eval (first clause) pred-env) actual-value)
              (eval (cons do (rest clause)) env)
              (process-clauses (rest clauses))))))
  (process-clauses clauses))

(def-const-op! with-env callsite-env (target-env &rest body)
  (eval (list* do body) (eval target-env callsite-env)))

(def-const-op! module dyn-env (parent-envs &rest body)
  (let (env (apply make-env (map (rcurry eval dyn-env) parent-envs)))
    (map (rcurry eval env) body)
    env))

(def-const-op! provide! dyn-env (bindings parent-envs &rest body)
  (let (module-env (eval (list* module parent-envs body) dyn-env))
    (map (lambda (binding)
           (eval (list def-in! dyn-env binding (eval binding module-env)) dyn-env))
         bindings))
  bindings)

(def-const-op! providing-module dyn-env (bindings parent-envs &rest body)
  (eval (list module (list)
              (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                     body))
        dyn-env))

(def-const-op! import-from! dyn-env (from-env &rest bindings)
  (let (env (eval from-env dyn-env))
    (map (lambda (binding)
           (let (var (if (list? binding) (car binding) binding)
                 val (list (unwrap eval) (if (list? binding) (car (cdr binding)) binding) env))
             (eval (list def-in! dyn-env var val) dyn-env)))
         bindings))
  bindings)

(def-const! anaphora
    (module (global-env)

            (def-const-op! anaphoric env (op var test &rest body)
              (eval (list let (list var (eval test env))
                          (list* op var body))
                    env))

            (def-const-op! aif env (var test then else)
              (eval (list anaphoric if var test then else) env))

            (def-const-op! awhen env (var test &rest body)
              (eval (list* anaphoric when var test body) env))

            (def-const-op! aunless env (var test &rest body)
              (eval (list* anaphoric unless var test body) env))

            (def-const-op! areturning env (var first &rest body)
              (eval (list* anaphoric returning var first body) env))

            ))

(def-const-fun! fibonacci (n)
  (if (<? n 2)
      n
      (+ (fibonacci (- n 1)) (fibonacci (- n 2)))))

(def-const-fun! factorial (n)
  (if (<? n 2)
      1
      (* n (factorial (- n 1)))))

(def-const-op! quote #ignore (x) x)
