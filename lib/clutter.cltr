(def-var! ((vau env () env)) global ((vau env () env)))

(def-var! global %def!-expanders (list))

(def-var! global lambda
    (vau env (vau-list &rest body)
         (wrap (eval (list* vau #ignore vau-list body) env))))

(def-var! global get-current-env
  (wrap (vau env () env)))

(def-var! global map
  (lambda (function values)
    (if (eql? (list) values)
        (list)
        (cons (function (car values)) (map function (cdr values))))))

(def-var! global do
  (vau env (&rest body)
       (let ((last-value ()))
         (map (lambda (exp) (set-var! (get-current-env) last-value (eval exp env)))
              body)
         last-value)))

(def-var! global cond
    (vau env (&rest forms)
         (if (eql? forms ())
             #f
             (if (eval (car (car forms)) env)
                 (eval (list* do (cdr (car forms)))
                       env)
                 (eval (list* cond (cdr forms)) env)))))

(def-var! global assoc
    (lambda (key alist)
      (if (eql? alist (list))
          #f
          (if (eql? key (car (car alist)))
              (car alist)
              (assoc key (cdr alist))))))

(def-var! global let
    (vau env (clauses &rest body)
         (eval (list* (list* lambda (map car clauses) body)
                      (map (lambda (x) (car (cdr x))) clauses))
               env)))

(def-var! global when
  (vau env (test &rest body)
       (if (eval test env)
           (eval (list* do body) env)
           #f)))

(def-var! global unless
  (vau env (test &rest body)
       (if (eval test env)
           #f
           (eval (list* do body) env))))

(def-var! global returning
  (lambda (first &rest #ignore) first))

(def-var! global anaphoric
  (vau env (op var test &rest body)
       (eval (list let (list (list var (eval test env)))
                   (list* op var body))
             env)))

(def-var! global aif
  (vau env (var test then else)
       (eval (list anaphoric if var test then else) env)))

(def-var! global awhen
  (vau env (var test &rest body)
       (eval (list* anaphoric when var test body) env)))

(def-var! global aunless
  (vau env (var test &rest body)
       (eval (list* anaphoric unless var test body) env)))

(def-var! global areturning
  (vau env (var first &rest body)
       (eval (list* anaphoric returning var first body) env)))

(def-var! global build-sidetree-leaf
  (vau callsite-env (name target-env-form)
       (let ((target-env (eval target-env-form callsite-env)))
         (let ((target-parent (env-parent target-env)))
           (if target-parent
               (do
                   (unless (bound? name target-parent)
                     (eval (list build-sidetree-leaf name target-parent) callsite-env))
                   (areturning leaf (make-env (eval (list lookup name target-parent)
                                                    callsite-env))
                      (eval (list def-var! target-env name leaf) callsite-env)))
               (areturning root (make-env (list))
                           (eval (list def-var! target-env name root) callsite-env)))))))

(let ((definers-name (gensym "definers")))
  (def-var! global def!
    (vau env (place value)
         (cond
           ((symbol? place)
            (eval (list def-var! env place value) env))
           ((cons? place)
            (let ((expander (assoc (car place) %def!-expanders)))
              (eval (list* (cdr expander) (eval value env) (cdr place))
                    env)))))))

(def! %set!-specials (list))

(let ((setters-name (gensym "setters")))
  (def-var! global set!
    (vau env (variable value)
         (cond
           ((symbol? variable)
            (let ((special (assoc variable %set!-specials)))
              (if special
                  ((cdr special) (eval value env))
                  (eval (list set-var! env variable value) env))))
           ((cons? variable)
            (let ((expander (eval (list lookup (car variable) setters-name) env)))
              (eval (list* expander (eval value env) (cdr variable)) env))))))

  (def-var! global def-set!-expander!
    (vau env (name combiner)
         (unless (bound? setters-name env)
           (eval (list def! setters-name (make-env (env-parent env))) env))
         (eval (list def-lookup! combiner name setters-name) env))))

(def! push!
    (vau env (value place)
         (eval (list set! place (list cons value place))
               env)))

(def! def-def!-expander!
    (vau env (name combiner)
         (push! (cons name (eval combiner env)) %def!-expanders)))

(def-def!-expander! lookup
    (vau env (value symbol target-env)
         (eval (list def-lookup! (eval value env) symbol (eval target-env env))
               env)))

(def! curry
    (lambda (function &rest first-args)
      (lambda (&rest last-args)
        (apply function (append first-args last-args)))))

(def! rcurry
    (lambda (function &rest last-args)
      (lambda (&rest first-args)
        (apply function (append first-args last-args)))))

(def! with-env
    (vau callsite-env (target-env &rest body)
         (eval (list* do body) (eval target-env callsite-env))))

(def! apply
  (lambda (function args)
    (eval (cons (unwrap function) args) (get-current-env))))

(def! def-set!-special!
    (vau env (variable function)
         (push! (cons variable (eval function env)) %set!-specials)))

(def-set!-expander! lookup
    (vau env (value symbol target-env)
         (eval (list set-lookup! (eval value env) symbol (eval target-env env))
               env)))
