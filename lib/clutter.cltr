(def!-in ((vau env () env)) get-current-env
  (wrap (vau env () env)))

(def!-in (get-current-env) def!
  (vau env (var value)
       (eval (list def!-in env var (eval value env)) env)))

(def! lambda
    (vau env (vau-list &rest body)
         (wrap (eval (list* vau () vau-list body) env))))

(def! map
    (lambda (function values)
      (if (eql? (list) values)
          (list)
          (cons (function (car values)) (map function (cdr values))))))

(def! do
    (vau env (&rest body)
         (let ((last-value ()))
           (map (lambda (exp) (set! last-value (eval exp env)))
                body)
           last-value)))

(def! cond
    (vau env (&rest forms)
         (if (eql? forms ())
             #f
             (if (eval (car (car forms)) env)
                 (eval (list* do (cdr (car forms)))
                       env)
                 (eval (list* cond (cdr forms)) env)))))

(def! assoc
    (lambda (key alist)
      (if (eql? alist (list))
          #f
          (if (eql? key (car (car alist)))
              (car alist)
              (assoc key (cdr alist))))))

(def! let
    (vau env (clauses &rest body)
         (eval (list* (list* lambda (map car clauses) body)
                      (map (lambda (x) (car (cdr x))) clauses))
               env)))

(def! when
    (vau env (test &rest body)
         (if (eval test env)
             (eval (list* do body) env)
             #f)))

(def! unless
  (vau env (test &rest body)
       (if (eval test env)
           #f
           (eval (list* do body) env))))

(def! returning
    (vau env (first &rest body)
         (let ((return-val (eval first env)))
           (map (curry eval env) body)
           return-val)))

(def! anaphoric
    (vau env (op var test &rest body)
         (eval (list let (list (list var (eval test env)))
                     (list* op var body))
               env)))

(def! aif
    (vau env (var test then else)
         (eval (list anaphoric if var test then else) env)))

(def! awhen
    (vau env (var test &rest body)
         (eval (list* anaphoric when var test body) env)))

(def! aunless
    (vau env (var test &rest body)
         (eval (list* anaphoric unless var test body) env)))

(def! areturning
    (vau env (var first &rest body)
         (eval (list* anaphoric returning var first body) env)))

(def! push!
    (vau env (value place)
         (eval (list set! place (list cons value place))
               env)))

(def! curry
    (lambda (function &rest first-args)
      (lambda (&rest last-args)
        (apply function (append first-args last-args)))))

(def! rcurry
    (lambda (function &rest last-args)
      (lambda (&rest first-args)
        (apply function (append first-args last-args)))))

(def! with-env
    (vau callsite-env (target-env &rest body)
         (eval (list* do body) (eval target-env callsite-env))))

(def! apply
  (lambda (function args)
    (eval (cons (unwrap function) args) (get-current-env))))

(def! module
    (vau dyn-env (parent-envs &rest body)
         (let ((env (apply make-env (map (rcurry eval dyn-env) parent-envs))))
           (map (rcurry eval env) body)
           env)))

(def! provide!
    (vau dyn-env (bindings parent-envs &rest body)
         (let ((module-env (eval (list* module parent-envs body) dyn-env)))
           (map (lambda (binding)
                  (eval (list def!-in dyn-env binding (eval binding module-env)) dyn-env))
                bindings))
         bindings))

(def! providing-module
    (vau dyn-env (bindings parent-envs &rest body)
         (eval (list module (list)
                     (list* provide! bindings (map (curry eval dyn-env) parent-envs)
                            body))
               dyn-env)))

(def! import-from!
    (vau dyn-env (from-env &rest bindings)
         (let ((env (eval from-env dyn-env)))
           (map (lambda (binding)
                  (eval (list def!-in dyn-env binding (eval binding env)) dyn-env))
                bindings))
         bindings))
